"""This file is generated by "data/build_code.py"
It has been set to read only so that you don't edit it without using
build_code.py.
"""

from sqlalchemy import Column, Integer, String, Boolean
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.declarative import declared_attr

from factories import container_factory
from base_classes import Base

from math import sin, floor

# For testing
from pprint import pprint
from inspect import signature
import pdb

"""
Name, Description, Attribute_Type, Type, [(Values Name, Value type,
    (Modifiers of value), Decimal Places)]
Linear: (Level multiplier), (Starting Value)
Root: Not finished. Looks like square root function. Used for diminishing
    returns and things that get better the larger they are. (Starting value)
    [Currently approaches 100]

Curvy: (larger "0" means it reaches the cap quicker) (smaller [1] means it
    reaxhes the cap quicker) ([2] is the cap or maximum possible value)
    ([3] is the negative amount)
Sensitive: Like curvy but has decimals (larger [0] means it reaches the cap
    quicker) (smaller [1] means it reaches the cap quicker) ([2] is the cap
    or maximum possible value) ([3] is the negative amount)
Modifier: (larger [0] means greater amplitude), (larger [1] means greater
    steepness and faster increase), (greater [2]  means greater frequency of
    waves)
Percent: ???
Empty: Sets this value to take on the value of "maximum". Must be placed after
    "Maximum" in the list of variables
"""
PROFICIENCY_INFORMATION = [
    ("Health", "How much you can take before you die", "Vitality",
        [("Maximum", "linear", (2, 5, 0)),
         ("Current", "empty")]),
    ("Regeneration", "How quickly your wounds heal", "Vitality",
        [("Speed", "root", (1, 2))]),
    ("Recovery", "How quickly you recover from poisons and negative effects",
        "Vitality",
        [("Efficiency", "root", (0, 0))]),
    ("Climbing", "Your ability to climb obstacles", "Agility",
        [("Ability", "linear", (0.5, 0.5, 1))]),
    ("Storage", "Your carrying capacity", "Brawn",
        [("Maximum", "linear", (2, 10, 0)),
         ("Current", "empty")]),
    ("Encumbrance", "How much your are slowed down in combat by your "
                    "equipment", "Brawn",
        [("Amount", "root", (0, 0))]),
    ("Endurance", "Actions performed each day", "Resilience",
        [("Maximum", "linear", (1, 3, 0)),
         ("Current", "empty")]),
    ("Damage", "How much damage you do on each hit", "Brawn",
        [("Minimum", "linear", (1, 0, 0)),
         ("Maximum", "linear", (1, 1, 0)),
         ("Modifier", "linear", (.1, 1, 1))]),
    ("Speed", "How fast you attack", "Quickness",
        [("Speed", "linear", (0.03, 1, 2))]),
    ("Accuracy", "The chance of your attacks hitting their target.",
        "Agility",
        [("Accuracy", "root", (35, 0))]),
    ("First strike", "Chance to strike first", "Quickness",
        [("Chance", "root", (0, 0))]),
    ("Killshot", "Ability to hit enemies in their weak spot", "Agility",
        [("Chance", "root", (0, 0)),
         ("Modifier", "linear", (0.1, 1, 1))]),
    ("Defence", "Damage reduction", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Evade", "Chance to dodge", "Quickness",
        [("Chance", "root", (5, 0))]),
    ("Parry", "Chance to parry", "Quickness",
        [("Chance", "root", (2, 0))]),
    ("Flee", "Chance to run from a battle", "Quickness",
        [("Chance", "root", (7, 0))]),
    ("Riposte", "Chance to riposte an enemy attack", "Agility",
        [("Chance", "root", (0, 0))]),
    ("Fatigue", "How quickly you tire in combat", "Resilience",
        [("Maximum", "linear", (1, 5, 0)),
         ("Current", "empty")]),
    ("Block", "Ability to block if a shield is equipped", "Resilience",
        [("Chance", "root", (0, 0)),
         ("Modifier", "root", (0, 0))]),
    ("Stealth", "Chance to avoid detection", "Agility",
        [("Chance", "root", (3, 0))]),
    ("Pickpocketing", "Skill at stealing from others", "Agility",
        [("Chance", "root", (1, 0))]),
    ("Faith", "Strength of spells you cast", "Divinity",
        [("Modifier", "linear", (0.1, 1, 0))]),
    ("Sanctity", "Amount of sanctity you can have", "Divinity",
        [("Maximum", "linear", (3, 0, 0)),
         ("Current", "empty")]),
    ("Resist holy", "Ability to resist holy damage", "Divinity",
        [("Modifier", "root", (0, 0))]),
    ("Bartering", "Discount from negotiating prices", "Charisma",
        [("Modifier", "linear", (-0.05, 1, 0))]),
    ("Oration", "Proficiency in speaking to others", "Charisma",
        [("Modifier", "root", (11, 0))]),
    ("Charm", "How quickly other people will like you", "Charisma",
        [("Modifier", "root", (3, 0))]),
    ("Trustworthiness", "How much other players trust you", "Charisma",
        [("Modifier", "root", (0, 0))]),
    ("Renown", "How much your actions affect your reputation", "Charisma",
        [("Modifier", "linear", (0.1, 1, 0))]),
    ("Knowledge", "Ability to understand", "Intellect",
        [("Modifier", "root", (6, 0))]),
    ("Literacy", "Ability to read", "Intellect",
        [("Modifier", "root", (0, 0))]),
    ("Understanding", "How quickly you level up", "Intellect",
        [("Modifier", "linear", (0.05, 1, 0))]),
    ("Luckiness", "Chance to have things turn your way against all odds",
        "Fortuity",
        [("Chance", "linear", (0.01, 0, 0))]),
    ("Adventuring", "Chance to discover treasure", "Fortuity",
        [("Chance", "root", (0, 0))]),
    ("Logistics",  "How far you can move on the map", "Pathfinding",
        [("Modifier", "linear", (0.2, 1, 0))]),
    ("Mountaineering", "Modifier for mountain movement", "Pathfinding",
        [("Modifier", "linear", (0.5, 1, 0))]),
    ("Woodsman", "Modifier for forest movement", "Pathfinding",
        [("Modifier", "linear", (.5, 1, 0))]),
    ("Navigator", "Modifier for water movement", "Pathfinding",
        [("Modifier", "linear", (.5, 1, 0))]),
    ("Detection", "Chance to discover enemy stealth and traps", "Survivalism",
        [("Chance", "root", (0, 0))]),
    ("Caution",  "See information about a new grid before going there",
        "Survivalism",
        [("Ability", "linear", (0.5, 0.5, 0))]),
    ("Explorer", "Additional options on the map, such as foraging",
        "Survivalism",
        [("Ability", "linear", (0.5, 0.5, 0))]),
    ("Huntsman", "Learn additional information about enemies",
        "Survivalism",
        [("Ability", "linear", (0.5, 0.5, 0))]),
    ("Survivalist", "Create bandages, tents, and other useful objects",
        "Survivalism",
        [("Ability", "linear", (0.5, 0.5, 0))]),
    ("Resist frost", "Ability to resist frost damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Resist flame", "Ability to resist flame damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Resist shadow", "Ability to resist shadow damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Resist poison", "Ability to resist poison damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Resist blunt", "Ability to resist blunt damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Resist slashing", "Ability to resist slashing damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Resist piercing", "Ability to resist piercing damage", "Resilience",
        [("Modifier", "root", (0, 0))]),
    ("Courage", "Your ability to overcome fears", "Willpower",
        [("Skill", "linear", (1, 0, 0))]),
    ("Sanity", "Your ability to resist mind altering affects", "Willpower",
        [("Skill", "linear", (1, 0, 0))]),
]

ALL_PROFICIENCIES = [attrib[0].lower().replace(" ", "_")
                     for attrib in PROFICIENCY_INFORMATION]

ALL_PROFICIENCY_COLUMNS = sorted({column[0].lower()
                           for prof in PROFICIENCY_INFORMATION
                           for column in prof[3]})

ALL_PROFICIENCY_NAMES = [attrib[0] for attrib in PROFICIENCY_INFORMATION]

# class ProficiencyMixin(object):
#     name = Column(String, default=cls.__name__)


class Proficiency(Base):
    """Proficiency class that stores data about a hero object.
    """
    __tablename__ = "proficiency"
    
    id = Column(Integer, primary_key=True)

    name = Column(String)
    description = Column(String)
    tooltip = Column(String)
    attribute_type = Column(String)
    level = Column(Integer)
    next_value = Column(Integer)
    is_not_max_level = Column(Boolean)  # Maybe remove
    reason_for_zero = Column(String)    # Maybe remove

    # Extra Ability columns
    error = Column(String)
    formatted_name = Column(String)
    ability = Column(Integer)
    accuracy = Column(Integer)
    amount = Column(Integer)
    chance = Column(Integer)
    current = Column(Integer)
    efficiency = Column(Integer)
    maximum = Column(Integer)
    minimum = Column(Integer)
    modifier = Column(Integer)
    skill = Column(Integer)
    speed = Column(Integer)

    # Relationships
    proficiencies_id = Column(Integer, ForeignKey('proficiencies.id'))
    proficiencies = relationship("Proficiencies")

    __mapper_args__ = {
        'polymorphic_identity': "Proficiency",
        'polymorphic_on': name
    }

    def __init__(self):
        self.name = self.__class__.__name__
        self.formatted_name = self.name.lower().replace(" ", "_")
        self.tooltip = ""
        # self.reason_for_zero = ""
        self.level = 0
        # self.is_not_max_level = False

    def is_max_level(self):
        """Return whether proficiency is max level.

        Should be able to get hero internally but the
        relationships may be messed up.

        Replaces:
            is_not_max_level attribute.
        """

        return self.level >= getattr(
            self.proficiencies.hero.attributes,
            self.attribute_type.lower()
        ).level // 2

    def level_up(self):
        self.level += 1


class DynamicMixin(object):
    @declared_attr
    def __mapper_args__(cls):
        return {'polymorphic_identity': cls.__name__}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.maximum = 0
        self.current = 0

    @property
    def percent(self):
        try:
            return round(self.current / self.maximum, 2) * 100
        except ZeroDivisionError:
            return 0

    def generic_update(self, hero):
        """Generic update function.
        """
        # This creates a tooltip for each variable
        tooltips = ["Maximum: {}".format(self.maximum)]
        # This updates the main tooltip string variable.
        self.tooltip = ';'.join(tooltips)

        for item in hero.equipped_items():
            try:
                self.maximum += item.health_maximum
            except AttributeError:
                # If the item doesn't have this attribute, don't worry about
                # it.
                pass

        for ability in hero.abilities:
            try:
                this_name = self.name.lower() + "_maximum"
                # Should be self.maximum += ability.this_name * ability.level
                # Then it would work for all cases with just that code. Right now they all add to the health maximum.
                self.maximum += ability.health_maximum * ability.level
            except AttributeError:
                # If the item doesn't have this attribute, don't worry about
                # it.
                pass

    def get_modifiable(self):
        """Return modifiable columns for this class.

        Possible options:
            [(key, getattr(self, key)) for key in attrib_names]
        OR
            [getattr(self, key) for key in attrib_names]
        """
        attrib_names = ['maximum']
        return [getattr(self, key) for key in attrib_names]


class Health(DynamicMixin, Proficiency):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How much you can take before you die"
        self.attribute_type = "Vitality"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Health's attributes and tooltip variable.
        """

        self.maximum = round(2 * self.level + 5, 0)
        self.current = self.maximum
        super().generic_update(hero)


class Sanctity(DynamicMixin, Proficiency):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Amount of sanctity you can have"
        self.attribute_type = "Divinity"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Sanctity's attributes and tooltip variable.
        """

        self.maximum = round(3 * self.level + 0, 0)
        self.current = self.maximum
        super().generic_update(hero)


class Endurance(DynamicMixin, Proficiency):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Actions performed each day"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Endurance's attributes and tooltip variable.
        """
        self.maximum = round(1 * self.level + 3, 0)
        self.current = self.maximum
        super().generic_update(hero)


class Storage(DynamicMixin, Proficiency):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Your carrying capacity"
        self.attribute_type = "Brawn"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Storage's attributes and tooltip variable.
        """

        self.maximum = round(2 * self.level + 10, 0)
        self.current = self.maximum
        super().generic_update(hero)


class StaticMixin(object):
    @declared_attr
    def __mapper_args__(cls):
        return {'polymorphic_identity': cls.__name__}

    def __init__(self, *args, **kwargs):
        """Generic init for static classes.

        Main usage is to set init values to 0.
        Example (the code does):
            self.speed = 0
        OR
            self.skill = 0
        """
        super().__init__(*args, **kwargs)
        for attrib in self.modifiable_on:
            setattr(self, attrib, 0)

    @property
    def modifiable_on(self):
        return ['ability', 'accuracy', 'amount', 'chance', 'efficiency',
                'maximum', 'minimum', 'modifier', 'skill', 'speed']

    def get_all_modifiable(self):
        """Return modifiable columns for this class.

        Possible options:
            [(key, getattr(self, key)) for key in attrib_names]
        OR
            [getattr(self, key) for key in attrib_names]
        """
        return [getattr(self, key) for key in self.modifiable_on]

    def generic_update(self, hero):
        """Generic update function.

        Requires that modifiable_on be declared in
        subclass.

        Usage does:
            for item in hero.equipped_items():
                self.efficiency += item.recovery_efficiency
            for ability in hero.abilities:
                self.efficiency += ability.recovery_efficiency * ability.level
        OR
            for item in hero.equipped_items():
                self.speed += item.regeneration_speed
            for ability in hero.abilities:
                self.speed += ability.regeneration_speed * ability.level

        Also sets the tooltip variable. Which will probably get moved to JS.
        """
        tooltips = []
        for attrib in self.modifiable_on:
            # This creates a tooltip for each variable
            tooltips.append("{}: {}".format(attrib.capitalize(), getattr(
                self, attrib, 'error')))

            item_attrib = self.__class__.__name__.lower() + attrib
            for item in hero.equipped_items():
                new_value = 0
                try:
                    new_value = getattr(item, item_attrib)
                except AttributeError:
                    # If the item doesn't have this attribute, don't worry
                    # about it.
                    pass
                new_value += getattr(self, attrib)
                setattr(self, attrib, new_value)

            for ability in hero.abilities:
                new_value = 0
                try:
                    new_value = getattr(ability, item_attrib)
                except AttributeError:
                    # If the item doesn't have this attribute, don't worry
                    # about it.
                    pass
                new_value *= ability.level
                new_value += getattr(self, attrib)
                setattr(self, attrib, new_value)

        # This updates the main tooltip string variable.
        self.tooltip = ';'.join(tooltips)


class Regeneration(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['speed']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How quickly your wounds heal"
        self.attribute_type = "Vitality"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Regeneration's attributes and tooltip variable.
        """
        self.speed = round((100 * self.level)**0.5 - (self.level / 4) + 1, 2)
        super().generic_update(hero)


class Recovery(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['efficiency', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How quickly you recover from poisons and negative effects"
        self.attribute_type = "Vitality"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Recovery's attributes and tooltip variable.
        """
        self.efficiency = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Climbing(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['ability', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Your ability to climb obstacles"
        self.attribute_type = "Agility"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Climbing's attributes and tooltip variable.
        """
        self.ability = round(0.5 * self.level + 0.5, 1)
        super().generic_update(hero)


class Encumbrance(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['amount', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How much your are slowed down in combat by your equipment"
        self.attribute_type = "Brawn"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Encumbrance's attributes and tooltip variable.
        """
        self.amount = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Damage(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['minimum', 'maximum', 'modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How much damage you do on each hit"
        self.attribute_type = "Brawn"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Damage's attributes and tooltip variable.
        """
        self.minimum = round(1 * self.level + 0, 0)
        self.maximum = round(1 * self.level + 1, 0)
        self.modifier = round(0.1 * self.level + 1, 1)
        super().generic_update(hero)


class Speed(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['speed', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How fast you attack"
        self.attribute_type = "Quickness"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Speed's attributes and tooltip variable.
        """
        self.speed = round(0.03 * self.level + 1, 2)
        super().generic_update(hero)


class Accuracy(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['accuracy', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "The chance of your attacks hitting their target."
        self.attribute_type = "Agility"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Accuracy's attributes and tooltip variable.
        """
        self.accuracy = round((100 * self.level)**0.5 - (self.level / 4) + 35, 0)
        super().generic_update(hero)


class FirstStrike(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to strike first"
        self.attribute_type = "Quickness"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update FirstStrike's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Killshot(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', 'modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to hit enemies in their weak spot"
        self.attribute_type = "Agility"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Killshot's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        self.modifier = round(0.1 * self.level + 1, 1)
        super().generic_update(hero)


class Defence(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Damage reduction"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Defence's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Evade(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to dodge"
        self.attribute_type = "Quickness"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Evade's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 5, 0)
        super().generic_update(hero)


class Parry(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to parry"
        self.attribute_type = "Quickness"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Parry's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 2, 0)
        super().generic_update(hero)


class Flee(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to run from a battle"
        self.attribute_type = "Quickness"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Flee's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 7, 0)
        super().generic_update(hero)


class Riposte(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to riposte an enemy attack"
        self.attribute_type = "Agility"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Riposte's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Fatigue(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['maximum', 'current', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How quickly you tire in combat"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Fatigue's attributes and tooltip variable.
        """
        self.maximum = round(1 * self.level + 5, 0)
        self.current = self.maximum
        super().generic_update(hero)


class Block(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', 'modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to block if a shield is equipped"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Block's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        if hero.inventory.left_hand is None or hero.inventory.left_hand.type != "Shield":
            self.chance = 0
            self.reason_for_zero = "You must have a shield equipped"
        else:
            self.reason_for_zero = ""
        super().generic_update(hero)


class Stealth(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to avoid detection"
        self.attribute_type = "Agility"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Stealth's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 3, 0)
        super().generic_update(hero)


class Pickpocketing(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Skill at stealing from others"
        self.attribute_type = "Agility"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Pickpocketing's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 1, 0)
        super().generic_update(hero)


class Faith(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Strength of spells you cast"
        self.attribute_type = "Divinity"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Faith's attributes and tooltip variable.
        """
        self.modifier = round(0.1 * self.level + 1, 0)
        super().generic_update(hero)


class ResistHoly(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist holy damage"
        self.attribute_type = "Divinity"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistHoly's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Bartering(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Discount from negotiating prices"
        self.attribute_type = "Charisma"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Bartering's attributes and tooltip variable.
        """
        self.modifier = round(-0.05 * self.level + 1, 0)
        super().generic_update(hero)


class Oration(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Proficiency in speaking to others"
        self.attribute_type = "Charisma"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Oration's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 11, 0)
        super().generic_update(hero)


class Charm(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How quickly other people will like you"
        self.attribute_type = "Charisma"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Charm's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 3, 0)
        super().generic_update(hero)


class Trustworthiness(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How much other players trust you"
        self.attribute_type = "Charisma"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Trustworthiness's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Renown(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How much your actions affect your reputation"
        self.attribute_type = "Charisma"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Renown's attributes and tooltip variable.
        """
        self.modifier = round(0.1 * self.level + 1, 0)
        super().generic_update(hero)


class Knowledge(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to understand"
        self.attribute_type = "Intellect"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Knowledge's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 6, 0)
        super().generic_update(hero)


class Literacy(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to read"
        self.attribute_type = "Intellect"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Literacy's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Understanding(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How quickly you level up"
        self.attribute_type = "Intellect"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Understanding's attributes and tooltip variable.
        """
        self.modifier = round(0.05 * self.level + 1, 0)
        super().generic_update(hero)


class Luckiness(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to have things turn your way against all odds"
        self.attribute_type = "Fortuity"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Luckiness's attributes and tooltip variable.
        """
        self.chance = round(0.01 * self.level + 0, 0)
        super().generic_update(hero)


class Adventuring(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to discover treasure"
        self.attribute_type = "Fortuity"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Adventuring's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Logistics(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "How far you can move on the map"
        self.attribute_type = "Pathfinding"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Logistics's attributes and tooltip variable.
        """
        self.modifier = round(0.2 * self.level + 1, 0)
        super().generic_update(hero)


class Mountaineering(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Modifier for mountain movement"
        self.attribute_type = "Pathfinding"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Mountaineering's attributes and tooltip variable.
        """
        self.modifier = round(0.5 * self.level + 1, 0)
        super().generic_update(hero)


class Woodsman(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Modifier for forest movement"
        self.attribute_type = "Pathfinding"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Woodsman's attributes and tooltip variable.
        """
        self.modifier = round(0.5 * self.level + 1, 0)
        super().generic_update(hero)


class Navigator(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Modifier for water movement"
        self.attribute_type = "Pathfinding"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Navigator's attributes and tooltip variable.
        """
        self.modifier = round(0.5 * self.level + 1, 0)
        super().generic_update(hero)


class Detection(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['chance', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Chance to discover enemy stealth and traps"
        self.attribute_type = "Survivalism"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Detection's attributes and tooltip variable.
        """
        self.chance = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Caution(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['ability', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "See information about a new grid before going there"
        self.attribute_type = "Survivalism"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Caution's attributes and tooltip variable.
        """
        self.ability = round(0.5 * self.level + 0.5, 0)
        super().generic_update(hero)


class Explorer(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['ability', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Additional options on the map, such as foraging"
        self.attribute_type = "Survivalism"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Explorer's attributes and tooltip variable.
        """
        self.ability = round(0.5 * self.level + 0.5, 0)
        super().generic_update(hero)


class Huntsman(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['ability', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Learn additional information about enemies"
        self.attribute_type = "Survivalism"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Huntsman's attributes and tooltip variable.
        """
        self.ability = round(0.5 * self.level + 0.5, 0)
        super().generic_update(hero)


class Survivalist(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['ability', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Create bandages, tents, and other useful objects"
        self.attribute_type = "Survivalism"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Survivalist's attributes and tooltip variable.
        """
        self.ability = round(0.5 * self.level + 0.5, 0)
        super().generic_update(hero)


class ResistFrost(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist frost damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistFrost's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class ResistFlame(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist flame damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistFlame's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class ResistShadow(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist shadow damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistShadow's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class ResistPoison(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist poison damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistPoison's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class ResistBlunt(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist blunt damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistBlunt's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class ResistSlashing(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist slashing damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistSlashing's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class ResistPiercing(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['modifier', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Ability to resist piercing damage"
        self.attribute_type = "Resilience"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update ResistPiercing's attributes and tooltip variable.
        """
        self.modifier = round((100 * self.level)**0.5 - (self.level / 4) + 0, 0)
        super().generic_update(hero)


class Courage(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['skill', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Your ability to overcome fears"
        self.attribute_type = "Willpower"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Courage's attributes and tooltip variable.
        """
        self.skill = round(1 * self.level + 0, 0)
        super().generic_update(hero)


class Sanity(StaticMixin, Proficiency):
    @property
    def modifiable_on(self):
        return ['skill', ]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.description = "Your ability to resist mind altering affects"
        self.attribute_type = "Willpower"
        self.error = "You do not have enough {}".format(self.attribute_type)

    def update(self, hero):
        """Update Sanity's attributes and tooltip variable.
        """
        self.skill = round(1 * self.level + 0, 0)
        super().generic_update(hero)


Proficiencies = container_factory(
    "Proficiencies", "Proficiency", (Base,),
    ALL_PROFICIENCY_NAMES, locals()
)
